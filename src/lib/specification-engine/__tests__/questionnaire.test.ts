import { describe, test, expect } from 'vitest';
import { MarkdownGenerator, createNewQuestionnaire } from '../index';

describe('SpecCraft Specification Engine', () => {
  describe('QuestionnaireEngine', () => {
    test('should create a new questionnaire session', () => {
      const engine = createNewQuestionnaire('User Authentication', 'Add login functionality');
      const session = engine.getSession();
      
      expect(session.featureTitle).toBe('User Authentication');
      expect(session.featureDescription).toBe('Add login functionality');
      expect(session.currentQuestionIndex).toBe(0);
      expect(session.responses).toHaveLength(0);
      expect(session.isComplete).toBe(false);
    });

    test('should get current question', () => {
      const engine = createNewQuestionnaire('Test Feature', 'Test description');
      const currentQuestion = engine.getCurrentQuestion();
      
      expect(currentQuestion).toBeTruthy();
      expect(currentQuestion?.id).toBe('feature-overview');
      expect(currentQuestion?.required).toBe(true);
    });

    test('should answer questions and advance', () => {
      const engine = createNewQuestionnaire('Test Feature', 'Test description');
      
      engine.answerCurrentQuestion('This feature will provide user authentication capabilities');
      
      const responses = engine.getAllResponses();
      expect(responses).toHaveLength(1);
      expect(responses[0].questionId).toBe('feature-overview');
      expect(responses[0].value).toBe('This feature will provide user authentication capabilities');
    });

    test('should track progress correctly', () => {
      const engine = createNewQuestionnaire('Test Feature', 'Test description');
      
      const initialProgress = engine.getProgress();
      expect(initialProgress.current).toBe(0);
      expect(initialProgress.percentage).toBe(0);
      
      engine.answerCurrentQuestion('Test answer');
      
      const updatedProgress = engine.getProgress();
      expect(updatedProgress.current).toBe(1);
      expect(updatedProgress.percentage).toBeGreaterThan(0);
    });

    test('should handle required question validation', () => {
      const engine = createNewQuestionnaire('Test Feature', 'Test description');
      
      expect(() => {
        engine.answerCurrentQuestion('');
      }).toThrow('This question is required');
    });

    test('should handle conditional questions', () => {
      const engine = createNewQuestionnaire('Test Feature', 'Test description');
      
      // Answer enough questions to get to sensitive-data question
      engine.answerCurrentQuestion('Feature overview');
      engine.answerCurrentQuestion('Target users');
      engine.answerCurrentQuestion('Business value');
      // ... continue until we reach the sensitive-data question
      
      const availableQuestions = engine.getAvailableQuestions();
      const sensitiveDataQuestion = availableQuestions.find(q => q.id === 'sensitive-data');
      expect(sensitiveDataQuestion).toBeTruthy();
    });
  });

  describe('MarkdownGenerator', () => {
    test('should generate markdown from responses', () => {
      const engine = createNewQuestionnaire('User Login', 'User authentication feature');
      
      engine.answerCurrentQuestion('This feature enables users to log into the application securely');
      engine.answerCurrentQuestion('End users, administrators');
      engine.answerCurrentQuestion('Secure access to user accounts');
      
      const responses = engine.getAllResponses();
      const generator = new MarkdownGenerator(responses);
      const markdown = generator.generateMarkdown('User Login');
      
      expect(markdown).toContain('# Feature: User Login');
      expect(markdown).toContain('## Overview');
      expect(markdown).toContain('This feature enables users to log into the application securely');
      expect(markdown).toContain('*Generated by SpecCraft');
    });

    test('should generate specification template', () => {
      const engine = createNewQuestionnaire('User Login', 'User authentication feature');
      
      engine.answerCurrentQuestion('Enable secure user authentication');
      engine.answerCurrentQuestion('End users');
      
      const responses = engine.getAllResponses();
      const generator = new MarkdownGenerator(responses);
      const template = generator.generateSpecificationTemplate();
      
      expect(template.overview).toBe('Enable secure user authentication');
      expect(template.userStories).toBeInstanceOf(Array);
      expect(template.functionalRequirements).toBeInstanceOf(Array);
    });
  });

  describe('Integration', () => {
    test('should complete full questionnaire flow', () => {
      const engine = createNewQuestionnaire('Complete Feature', 'Full test');
      
      // Answer questions one by one, checking if they exist and are required
      let currentQuestion = engine.getCurrentQuestion();
      let questionCount = 0;
      
      const answers = [
        'Comprehensive feature overview',
        'Target user groups',
        'Clear business value',
        'Core functionality list',
        'User interaction flow',
        'Data requirements',
        'External integrations needed',
        'UI requirements',
        true, // responsive design
        'Accessibility requirements',
        'Performance needs',
        'Scalability requirements',
        false, // sensitive data
        'Required authentication',
        'Error scenarios',
        'Validation rules',
        'Edge cases',
        'Feature dependencies',
        'Timeline constraints',
        'Success criteria'
      ];
      
      let answerIndex = 0;
      while (currentQuestion && answerIndex < answers.length) {
        const answer = answers[answerIndex];
        
        // Provide a valid answer for required questions
        if (currentQuestion.required && (!answer || answer === '')) {
          engine.answerCurrentQuestion('Default required answer');
        } else {
          engine.answerCurrentQuestion(answer);
        }
        
        questionCount++;
        answerIndex++;
        currentQuestion = engine.getCurrentQuestion();
      }
      
      const progress = engine.getProgress();
      expect(progress.current).toBeGreaterThan(5); // Should have answered multiple questions
      expect(questionCount).toBeGreaterThan(5); // Should have processed multiple questions
    });
  });
});