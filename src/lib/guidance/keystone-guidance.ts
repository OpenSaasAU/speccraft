import type { ParsedSpecification } from "../code-generation/spec-reader.js";

export interface KeystoneGuidance {
  schemas: SchemaGuidance[];
  hooks: HookGuidance[];
  adminUI: AdminUIGuidance[];
  accessControl: AccessControlGuidance[];
  examples: CodeExample[];
  patterns: ImplementationPattern[];
}

export interface SchemaGuidance {
  purpose: string;
  fields: FieldGuidance[];
  relationships: RelationshipGuidance[];
  example: string;
}

export interface FieldGuidance {
  name: string;
  type: string;
  purpose: string;
  validation?: string;
  example: string;
}

export interface RelationshipGuidance {
  field: string;
  type: "one-to-one" | "one-to-many" | "many-to-many";
  target: string;
  purpose: string;
  example: string;
}

export interface HookGuidance {
  type: "resolveInput" | "validateInput" | "beforeOperation" | "afterOperation";
  purpose: string;
  when: string;
  example: string;
}

export interface AdminUIGuidance {
  component: string;
  purpose: string;
  when: string;
  example: string;
}

export interface AccessControlGuidance {
  operation: "create" | "read" | "update" | "delete";
  pattern: string;
  purpose: string;
  example: string;
}

export interface CodeExample {
  title: string;
  description: string;
  code: string;
  useCase: string;
}

export interface ImplementationPattern {
  name: string;
  description: string;
  when: string;
  steps: string[];
  example?: string;
}

export interface ArchitectureGuidance {
  fileStructure: string;
  keystoneSetup: string;
  nextAuthSetup: string;
  apiRoutes: string;
  criticalPatterns: string[];
}

export class KeystoneGuidanceProvider {
  generateImplementationGuidance(spec: ParsedSpecification): KeystoneGuidance {
    return {
      schemas: this.generateSchemaGuidance(spec),
      hooks: this.generateHookGuidance(spec),
      adminUI: this.generateAdminUIGuidance(spec),
      accessControl: this.generateAccessControlGuidance(spec),
      examples: this.getRelevantExamples(spec),
      patterns: this.getImplementationPatterns(spec),
    };
  }

  generateArchitectureGuidance(
    spec: ParsedSpecification,
    requiresAuth: boolean,
  ): ArchitectureGuidance {
    return {
      fileStructure: this.getOpinionatedFileStructure(),
      keystoneSetup: this.getKeystoneContextSetup(),
      nextAuthSetup: requiresAuth ? this.getNextAuthSetup() : "",
      apiRoutes: this.getAPIRouteSetup(),
      criticalPatterns: this.getCriticalPatterns(requiresAuth),
    };
  }

  generateClaudeMd(spec: ParsedSpecification, requiresAuth: boolean): string {
    return `# ${spec.title} - Development Guide

**Architecture**: Next.js 15 + KeystoneJS 6 + Neon PostgreSQL${requiresAuth ? " + NextAuth 5" : ""}
**Generated by**: SpecCraft
**Specification**: See \`SPECIFICATION.md\`

---

## üèóÔ∏è Architecture Overview

This project follows the **opinionated architecture** from [on-the-hill-drama-club](https://github.com/borisno2/on-the-hill-drama-club):

- **Next.js 15** with App Router for frontend and API routes
- **KeystoneJS 6** embedded via \`getContext()\` (NOT as separate server)
- **Neon PostgreSQL** with serverless adapter for Vercel deployment
${requiresAuth ? "- **NextAuth 5** for authentication integrated with Keystone" : ""}
- **GraphQL Yoga** for GraphQL API endpoint
- **Server Actions** for all mutations (no custom GraphQL resolvers)

---

## ‚ö†Ô∏è CRITICAL: Must-Follow Patterns

### Keystone Integration

‚ùå **NEVER** run Keystone as a separate server
‚úÖ **ALWAYS** use \`getContext()\` to embed Keystone in Next.js

\`\`\`typescript
// WRONG: Don't do this
import { createServer } from '@keystone-6/core';

// RIGHT: Do this
import { keystoneContext } from '@/keystone/context';
\`\`\`

### Data Operations

‚ùå **NEVER** use \`keystoneContext.query\` directly in server actions
‚ùå **NEVER** call \`/api/graphql\` from server-side code
‚úÖ **ALWAYS** use \`keystoneContext.graphql.run()\` for GraphQL operations

\`\`\`typescript
// WRONG: Don't use .query
const users = await keystoneContext.query.User.findMany();

// RIGHT: Use .graphql.run()
const users = await keystoneContext.graphql.run({
  query: \`query { users { id name email } }\`,
});
\`\`\`

### Type Safety

‚ùå **NEVER** use \`any\` for GraphQL types
‚úÖ **ALWAYS** use \`ResultOf<typeof QUERY>\` and \`VariablesOf<typeof QUERY>\`

\`\`\`typescript
import { ResultOf } from 'gql.tada';

const GET_USER = \`query GetUser($id: ID!) {
  user(where: { id: $id }) { id name email }
}\` as const;

type GetUserResult = ResultOf<typeof GET_USER>;
type GetUserVariables = VariablesOf<typeof GET_USER>;
\`\`\`

### Mutations

‚ùå **NEVER** create custom GraphQL resolvers for mutations
‚úÖ **ALWAYS** use Next.js Server Actions with Zod validation

\`\`\`typescript
'use server';
import { z } from 'zod';
import { keystoneContext } from '@/keystone/context';

const createUserSchema = z.object({
  name: z.string().min(1),
  email: z.string().email(),
});

export async function createUser(formData: FormData) {
  const validated = createUserSchema.parse({
    name: formData.get('name'),
    email: formData.get('email'),
  });

  const result = await keystoneContext.graphql.run({
    query: \`mutation CreateUser($data: UserCreateInput!) {
      createUser(data: $data) { id name email }
    }\`,
    variables: { data: validated },
  });

  return result;
}
\`\`\`

${
  requiresAuth
    ? `### Authentication

‚ùå **NEVER** bypass Keystone user sync in NextAuth
‚úÖ **ALWAYS** use \`keystoneContext.sudo()\` for auth-related queries
‚úÖ **ALWAYS** sync NextAuth users with Keystone User list

\`\`\`typescript
// In src/lib/auth.ts callbacks
async signIn({ user, account }) {
  // Use .sudo() to bypass access control
  const existing = await keystoneContext.sudo().query.User.findOne({
    where: { email: user.email! },
    query: 'id',
  });

  if (!existing) {
    await keystoneContext.sudo().query.User.createOne({
      data: { name: user.name!, email: user.email! },
    });
  }
  return true;
}
\`\`\`

### Session Access

‚úÖ **ALWAYS** use \`auth()\` from NextAuth to get session in API routes
‚úÖ **ALWAYS** pass session to Keystone context

\`\`\`typescript
import { auth } from '@/lib/auth';

export async function GET(req: Request) {
  const session = await auth();

  const context = keystoneContext.withSession(session);

  // Use context for queries
}
\`\`\`
`
    : ""
}

---

## üìÅ File Structure

\`\`\`
src/
‚îú‚îÄ‚îÄ app/                          # Next.js 15 App Router
‚îÇ   ‚îú‚îÄ‚îÄ api/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ graphql/route.ts      # GraphQL API (Yoga + Keystone)
${requiresAuth ? "‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ auth/[...nextauth]/   # NextAuth routes\n" : ""}‚îÇ   ‚îú‚îÄ‚îÄ admin/                    # Keystone Admin UI pages
‚îÇ   ‚îî‚îÄ‚îÄ (your routes)/            # Your app pages
‚îú‚îÄ‚îÄ keystone/
‚îÇ   ‚îú‚îÄ‚îÄ context/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.ts              # **CRITICAL**: getContext() setup
‚îÇ   ‚îú‚îÄ‚îÄ lists/                    # Schema definitions
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ User.ts               # User model
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ${this.pascalCase(spec.title)}.ts
‚îÇ   ‚îú‚îÄ‚îÄ schema.ts                 # Export all lists
‚îÇ   ‚îî‚îÄ‚îÄ helpers.ts                # Access control helpers
${requiresAuth ? "‚îú‚îÄ‚îÄ lib/\n‚îÇ   ‚îú‚îÄ‚îÄ auth.ts                   # NextAuth configuration\n‚îÇ   ‚îî‚îÄ‚îÄ utils.ts\n" : "‚îú‚îÄ‚îÄ lib/\n‚îÇ   ‚îî‚îÄ‚îÄ utils.ts\n"}‚îî‚îÄ‚îÄ types/
    ‚îî‚îÄ‚îÄ session.ts                # Session type definitions

keystone.ts                       # Root Keystone config
schema.prisma                     # Prisma schema
\`\`\`

---

## üöÄ Development Workflow

### Starting Development

\`\`\`bash
pnpm dev
\`\`\`

This starts:
- Next.js dev server: http://localhost:3000
- Keystone Admin UI: http://localhost:3000/admin
- GraphQL API: http://localhost:3000/api/graphql

### Database Migrations

\`\`\`bash
# Create a new migration
./generate-migration.sh migration_name

# Apply migrations
pnpm migrate:deploy
\`\`\`

### Adding a New Keystone List

1. Create file in \`src/keystone/lists/YourList.ts\`
2. Define your list with fields and access control
3. Export from \`src/keystone/schema.ts\`
4. Generate migration
5. Run migration

\`\`\`typescript
// src/keystone/lists/Post.ts
import { list } from '@keystone-6/core';
import { text, relationship, timestamp } from '@keystone-6/core/fields';
import { isLoggedIn } from '../helpers';

export const Post = list({
  access: {
    operation: {
      create: isLoggedIn,
      query: () => true,
      update: isLoggedIn,
      delete: isLoggedIn,
    },
  },
  fields: {
    title: text({ validation: { isRequired: true } }),
    content: text({ ui: { displayMode: 'textarea' } }),
    author: relationship({
      ref: 'User',
      hooks: {
        resolveInput: ({ context, operation }) => {
          if (operation === 'create') {
            return { connect: { id: context.session?.itemId } };
          }
        }
      }
    }),
    createdAt: timestamp({ defaultValue: { kind: 'now' } }),
  },
});
\`\`\`

### Creating a Server Action

1. Create file in \`src/app/actions/yourAction.ts\`
2. Add \`'use server'\` directive
3. Define Zod schema for validation
4. Use \`keystoneContext.graphql.run()\`
5. Use gql.tada for type-safe queries

\`\`\`typescript
'use server';
import { z } from 'zod';
import { keystoneContext } from '@/keystone/context';
import { graphql } from 'gql.tada';
import { auth } from '@/lib/auth';

const postSchema = z.object({
  title: z.string().min(1).max(200),
  content: z.string().min(1),
});

export async function createPost(formData: FormData) {
  const session = await auth();
  if (!session) throw new Error('Unauthorized');

  const validated = postSchema.parse({
    title: formData.get('title'),
    content: formData.get('content'),
  });

  const result = await keystoneContext.graphql.run({
    query: graphql(\`
      mutation CreatePost($data: PostCreateInput!) {
        createPost(data: $data) {
          id
          title
          content
          createdAt
        }
      }
    \`),
    variables: {
      data: {
        ...validated,
        author: { connect: { id: session.user.id } },
      }
    },
  });

  return result.createPost;
}
\`\`\`

---

## üîç Common Patterns

### User-Owned Content

\`\`\`typescript
export const MyContent = list({
  fields: {
    title: text({ validation: { isRequired: true } }),
    owner: relationship({
      ref: 'User',
      hooks: {
        resolveInput: ({ context, operation }) => {
          if (operation === 'create' && context.session?.itemId) {
            return { connect: { id: context.session.itemId } };
          }
        }
      }
    }),
  },
  access: {
    operation: {
      create: ({ session }) => !!session,
      query: ({ session }) => session ?
        { owner: { id: { equals: session.itemId } } } : false,
      update: ({ session, item }) =>
        session?.itemId === item.ownerId,
      delete: ({ session, item }) =>
        session?.itemId === item.ownerId,
    },
  },
});
\`\`\`

### Status Workflow

\`\`\`typescript
fields: {
  status: select({
    options: [
      { label: 'Draft', value: 'draft' },
      { label: 'Published', value: 'published' },
    ],
    defaultValue: 'draft',
  }),
  publishedAt: timestamp(),
},
hooks: {
  validateInput: ({ resolvedData, addValidationError }) => {
    if (resolvedData.status === 'published' && !resolvedData.publishedAt) {
      addValidationError('Published items must have publishedAt set');
    }
  },
}
\`\`\`

---

## üìö Key Resources

- **Your Specification**: \`SPECIFICATION.md\`
- **Keystone Docs**: https://keystonejs.com/docs
- **Next.js Docs**: https://nextjs.org/docs
${requiresAuth ? "- **NextAuth Docs**: https://authjs.dev\n" : ""}- **Reference Implementation**: https://github.com/borisno2/on-the-hill-drama-club

---

## üêõ Troubleshooting

### "getContext is not a function"
- Check that \`src/keystone/context/index.ts\` exists and exports \`keystoneContext\`
- Verify imports are using the correct path: \`@/keystone/context\`

### "Prisma Client failed to initialize"
- Run \`pnpm prisma generate\`
- Check DATABASE_URL is set in \`.env\`
- Ensure migrations are applied: \`pnpm migrate:deploy\`

${
  requiresAuth
    ? `### "Session not working"
- Verify NEXTAUTH_SECRET is set in \`.env\`
- Check NEXTAUTH_URL matches your domain
- Ensure \`auth()\` is being called in server components/actions
`
    : ""
}
### "GraphQL errors in Admin UI"
- Check that all lists are exported from \`src/keystone/schema.ts\`
- Verify \`keystone.ts\` imports schema correctly
- Restart dev server after schema changes

---

**Remember**: This architecture is proven in production. Follow these patterns exactly for best results! üöÄ`;
  }

  private getOpinionatedFileStructure(): string {
    return `## üìÅ Required File Structure (Based on on-the-hill-drama-club)

\`\`\`
src/
‚îú‚îÄ‚îÄ app/                          # Next.js 15 App Router
‚îÇ   ‚îú‚îÄ‚îÄ api/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ graphql/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ route.ts         # GraphQL API endpoint (uses Yoga + Keystone)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ auth/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ [...nextauth]/   # NextAuth routes (if auth required)
‚îÇ   ‚îú‚îÄ‚îÄ admin/                    # Keystone Admin UI pages
‚îÇ   ‚îî‚îÄ‚îÄ (your feature routes)/
‚îú‚îÄ‚îÄ keystone/
‚îÇ   ‚îú‚îÄ‚îÄ context/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.ts             # **CRITICAL**: getContext() setup
‚îÇ   ‚îú‚îÄ‚îÄ lists/                    # Keystone schema definitions
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ User.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ (your list).ts
‚îÇ   ‚îú‚îÄ‚îÄ schema.ts                 # Exports all lists
‚îÇ   ‚îî‚îÄ‚îÄ helpers.ts                # Access control helpers (isAdmin, isLoggedIn)
‚îú‚îÄ‚îÄ lib/
‚îÇ   ‚îú‚îÄ‚îÄ auth.ts                   # NextAuth configuration (if auth required)
‚îÇ   ‚îî‚îÄ‚îÄ utils.ts
‚îî‚îÄ‚îÄ types/
    ‚îî‚îÄ‚îÄ session.ts                # NextAuth session types

keystone.ts                       # Root Keystone config
schema.prisma                     # Prisma schema
\`\`\``;
  }

  private getKeystoneContextSetup(): string {
    return `## üîß Keystone Context Setup (CRITICAL)

**Location**: \`src/keystone/context/index.ts\`

\`\`\`typescript
import { getContext } from '@keystone-6/core/context';
import config from '../../../keystone';
import * as PrismaModule from '.prisma/client';
import { Pool, neonConfig } from '@neondatabase/serverless';
import { PrismaNeon } from '@prisma/adapter-neon';
import { Prisma PrismaClient } from '@prisma/client';

// Neon serverless driver for Vercel deployment
neonConfig.webSocketConstructor = ws;
const connectionString = process.env.DATABASE_URL!;

// Custom Prisma Client with Neon adapter
class NeonPrismaClient extends PrismaClient {
  constructor() {
    const pool = new Pool({ connectionString });
    const adapter = new PrismaNeon(pool);
    super({ adapter });
  }
}

// Global singleton pattern (prevents multiple instances in dev)
export const keystoneContext: Context =
  globalThis.keystoneContext ||
  getContext(config, { ...PrismaModule, PrismaClient: NeonPrismaClient });

if (process.env.NODE_ENV !== 'production') {
  globalThis.keystoneContext = keystoneContext;
}

// Export for use in API routes and server actions
export type Context = typeof keystoneContext;
\`\`\`

**Why This Matters**:
- ‚ùå **NEVER** start a separate GraphQL server
- ‚úÖ **ALWAYS** use \`getContext()\` to embed Keystone in Next.js
- ‚úÖ Use Neon adapter for serverless PostgreSQL on Vercel
- ‚úÖ Global singleton prevents multiple connections in development`;
  }

  private getNextAuthSetup(): string {
    return `## üîê NextAuth Configuration (CRITICAL for Auth Features)

**Location**: \`src/lib/auth.ts\`

\`\`\`typescript
import NextAuth from 'next-auth';
import GoogleProvider from 'next-auth/providers/google';
import CredentialsProvider from 'next-auth/providers/credentials';
import { keystoneContext } from '@/keystone/context';

export const { handlers, auth, signIn, signOut } = NextAuth({
  providers: [
    GoogleProvider({
      clientId: process.env.GOOGLE_CLIENT_ID!,
      clientSecret: process.env.GOOGLE_CLIENT_SECRET!,
    }),
    CredentialsProvider({
      name: 'Email and Password',
      credentials: {
        email: { label: 'Email', type: 'email' },
        password: { label: 'Password', type: 'password' },
      },
      async authorize(credentials) {
        if (!credentials?.email || !credentials?.password) return null;

        // **CRITICAL**: Use keystoneContext.sudo() for auth queries
        const user = await keystoneContext.sudo().query.User.findOne({
          where: { email: credentials.email },
          query: 'id name email password',
        });

        if (!user || !user.password) return null;

        // Verify password (implement your password verification)
        const isValid = await verifyPassword(credentials.password, user.password);
        if (!isValid) return null;

        return { id: user.id, name: user.name, email: user.email };
      },
    }),
  ],

  callbacks: {
    async signIn({ user, account, profile }) {
      // For OAuth providers, create user in Keystone if doesn't exist
      if (account?.provider !== 'credentials') {
        const existing = await keystoneContext.sudo().query.User.findOne({
          where: { email: user.email! },
          query: 'id',
        });

        if (!existing) {
          await keystoneContext.sudo().query.User.createOne({
            data: {
              name: user.name!,
              email: user.email!,
              // Set default role, etc.
            },
          });
        }
      }
      return true;
    },

    async session({ session, token }) {
      // **CRITICAL**: Fetch full user data from Keystone
      const user = await keystoneContext.sudo().query.User.findOne({
        where: { email: session.user?.email! },
        query: 'id name email role allowAdminUI',
      });

      if (user) {
        session.user.id = user.id;
        session.user.role = user.role;
        session.allowAdminUI = user.allowAdminUI || false;
      }

      return session;
    },
  },

  pages: {
    signIn: '/auth/signin',
    error: '/auth/error',
  },
});
\`\`\`

**Key Patterns**:
- ‚úÖ Use \`keystoneContext.sudo()\` for auth queries (bypasses access control)
- ‚úÖ Sync NextAuth users with Keystone User list
- ‚úÖ Store user roles and permissions in Keystone
- ‚úÖ Extend session with Keystone user data
- ‚úÖ Support both OAuth and credentials providers`;
  }

  private getAPIRouteSetup(): string {
    return `## üåê GraphQL API Route Setup

**Location**: \`src/app/api/graphql/route.ts\`

\`\`\`typescript
import { createYoga } from 'graphql-yoga';
import { keystoneContext } from '@/keystone/context';
import { auth } from '@/lib/auth';

const { handleRequest } = createYoga({
  schema: keystoneContext.graphql.schema,
  graphqlEndpoint: '/api/graphql',
  fetchAPI: { Response },
  context: async (req) => {
    // **CRITICAL**: Get NextAuth session
    const session = await auth();

    // Return Keystone context with session
    return keystoneContext.withRequest(req, {
      session: session ? {
        itemId: session.user.id,
        data: session.user,
        allowAdminUI: session.allowAdminUI,
      } : undefined,
    });
  },
});

// Protected GraphQL endpoint (requires auth)
export async function GET(req: Request) {
  const session = await auth();
  if (!session?.allowAdminUI) {
    return new Response('Unauthorized', { status: 401 });
  }
  return handleRequest(req, {});
}

export async function POST(req: Request) {
  const session = await auth();
  if (!session?.allowAdminUI) {
    return new Response('Unauthorized', { status: 401 });
  }
  return handleRequest(req, {});
}

export async function OPTIONS(req: Request) {
  return handleRequest(req, {});
}
\`\`\`

**Critical Points**:
- ‚úÖ Use GraphQL Yoga (not Apollo Server)
- ‚úÖ Integrate NextAuth session with Keystone context
- ‚úÖ Protect GraphQL endpoint with auth middleware
- ‚úÖ Use \`keystoneContext.withRequest()\` to pass session`;
  }

  private getCriticalPatterns(requiresAuth: boolean): string[] {
    const patterns = [
      "‚ùå **NEVER** run Keystone as a separate server - use getContext() only",
      "‚úÖ **ALWAYS** use \`keystoneContext.graphql.run()\` for GraphQL queries in server actions",
      "‚úÖ **ALWAYS** use \`keystoneContext.sudo()\` for auth-related queries (bypasses access control)",
      "‚úÖ **ALWAYS** use Next.js Server Actions for mutations (NOT custom GraphQL resolvers)",
      "‚úÖ **ALWAYS** validate with Zod schemas before calling Keystone mutations",
      "‚úÖ **ALWAYS** use \`ResultOf<typeof QUERY>\` for GraphQL type inference (never \`any\`)",
      "‚úÖ **ALWAYS** use Neon serverless adapter for Vercel deployment",
      "‚úÖ **ALWAYS** define lists in separate files under \`src/keystone/lists/\`",
      "‚úÖ **ALWAYS** export all lists from \`src/keystone/schema.ts\`",
    ];

    if (requiresAuth) {
      patterns.push(
        "‚úÖ **ALWAYS** sync NextAuth users with Keystone User list",
        "‚úÖ **ALWAYS** extend NextAuth session with Keystone user data",
        "‚úÖ **ALWAYS** use \`auth()\` from NextAuth to get session in API routes",
      );
    }

    return patterns;
  }

  private generateSchemaGuidance(spec: ParsedSpecification): SchemaGuidance[] {
    const featureName = this.pascalCase(spec.title);

    return [
      {
        purpose: `Schema for ${spec.title} - ${spec.description}`,
        fields: this.inferFieldsFromSpec(spec),
        relationships: this.inferRelationshipsFromSpec(spec),
        example: `export const ${featureName} = list({
  fields: {
    // Add your fields here based on the specification requirements
    title: text({ validation: { isRequired: true } }),
    description: text({ ui: { displayMode: 'textarea' } }),

    // Relationships
    createdBy: relationship({
      ref: 'User',
      hooks: {
        resolveInput: ({ context }) => ({ connect: { id: context.session?.itemId } })
      }
    }),

    // Timestamps
    createdAt: timestamp({ defaultValue: { kind: 'now' } }),
    updatedAt: timestamp({ hooks: { resolveInput: () => new Date() } }),
  },

  ui: {
    label: '${spec.title}',
    labelField: 'title',
  },

  hooks: {
    // Add business logic hooks here
  },
});`,
      },
    ];
  }

  private generateHookGuidance(spec: ParsedSpecification): HookGuidance[] {
    const hooks: HookGuidance[] = [];

    // Auto-timestamp hook
    hooks.push({
      type: "resolveInput",
      purpose: "Automatically set updatedAt timestamp on every update",
      when: "Use this pattern for audit trails and tracking changes",
      example: `hooks: {
  resolveInput: ({ resolvedData, operation }) => {
    if (operation === 'update') {
      resolvedData.updatedAt = new Date();
    }
    return resolvedData;
  },
}`,
    });

    // Validation hook
    if (spec.functionalRequirements.businessRules.length > 0) {
      hooks.push({
        type: "validateInput",
        purpose: "Validate business rules before saving",
        when: "Use this to enforce business logic and data integrity",
        example: `hooks: {
  validateInput: ({ resolvedData, addValidationError }) => {
    // Example business rule validation
    if (resolvedData.status === 'published' && !resolvedData.publishedAt) {
      addValidationError('Published items must have a publication date');
    }
  },
}`,
      });
    }

    // Auto-assign user hook
    hooks.push({
      type: "resolveInput",
      purpose: "Automatically assign current user to new items",
      when: "Use this pattern for user-owned content",
      example: `fields: {
  createdBy: relationship({
    ref: 'User',
    hooks: {
      resolveInput: ({ context, operation }) => {
        if (operation === 'create') {
          return { connect: { id: context.session?.itemId } };
        }
        return undefined; // Don't change on update
      }
    }
  }),
}`,
    });

    return hooks;
  }

  private generateAdminUIGuidance(
    spec: ParsedSpecification,
  ): AdminUIGuidance[] {
    const guidance: AdminUIGuidance[] = [];

    // Custom field components
    if (spec.uiRequirements.interfaces.length > 0) {
      guidance.push({
        component: "Custom Field Component",
        purpose: "Create custom input components for complex fields",
        when: "When default Keystone fields don't meet your UI requirements",
        example: `// admin/components/CustomField.tsx
import { FieldProps } from '@keystone-6/core/types';

export const CustomField = ({ field, value, onChange }: FieldProps<string>) => {
  return (
    <div>
      <label>{field.label}</label>
      <input
        type="text"
        value={value || ''}
        onChange={e => onChange(e.target.value)}
      />
    </div>
  );
};

// In your schema:
fields: {
  customField: text({
    ui: {
      views: './admin/components/CustomField'
    }
  })
}`,
      });
    }

    // List views
    guidance.push({
      component: "Custom List View",
      purpose: "Customize how items appear in the admin list",
      when: "When you need custom formatting or actions in the admin",
      example: `ui: {
  listView: {
    initialColumns: ['title', 'status', 'createdAt'],
    defaultFieldMode: 'read',
    initialSort: { field: 'createdAt', direction: 'DESC' },
  },
}`,
    });

    return guidance;
  }

  private generateAccessControlGuidance(
    spec: ParsedSpecification,
  ): AccessControlGuidance[] {
    const guidance: AccessControlGuidance[] = [];

    // Basic user-based access
    guidance.push({
      operation: "create",
      pattern: "User can create their own items",
      purpose: "Allow authenticated users to create content",
      example: `access: {
  operation: {
    create: ({ session }) => !!session,
    query: () => true,
    update: ({ session, item }) => {
      if (!session) return false;
      return session.itemId === item.createdById;
    },
    delete: ({ session, item }) => {
      if (!session) return false;
      return session.itemId === item.createdById;
    },
  },
}`,
    });

    // Role-based access
    guidance.push({
      operation: "read",
      pattern: "Role-based access control",
      purpose: "Different permissions based on user roles",
      example: `access: {
  operation: {
    create: ({ session }) => session?.data.role === 'admin',
    query: ({ session }) => {
      if (!session) return false;
      if (session.data.role === 'admin') return true;
      return { createdBy: { id: { equals: session.itemId } } };
    },
  },
}`,
    });

    return guidance;
  }

  private getRelevantExamples(spec: ParsedSpecification): CodeExample[] {
    const examples: CodeExample[] = [];

    // Basic CRUD example
    examples.push({
      title: "Basic List with CRUD Operations",
      description: "Standard pattern for most content types",
      useCase: "Use this as a starting point for most features",
      code: `import { list } from '@keystone-6/core';
import { text, relationship, timestamp, select } from '@keystone-6/core/fields';

export const ${this.pascalCase(spec.title)} = list({
  fields: {
    title: text({ validation: { isRequired: true } }),
    description: text({ ui: { displayMode: 'textarea' } }),
    status: select({
      options: [
        { label: 'Draft', value: 'draft' },
        { label: 'Published', value: 'published' },
      ],
      defaultValue: 'draft',
    }),
    createdBy: relationship({ ref: 'User' }),
    createdAt: timestamp({ defaultValue: { kind: 'now' } }),
  },

  ui: {
    labelField: 'title',
  },
});`,
    });

    // Authentication context example
    examples.push({
      title: "Using Authentication Context",
      description: "Access current user in hooks and access control",
      useCase: "When you need to work with the currently logged-in user",
      code: `// In hooks or access control
({ context, session }) => {
  // Current user ID
  const userId = session?.itemId;

  // Current user data
  const userData = session?.data;

  // Query current user with relations
  const user = await context.query.User.findOne({
    where: { id: userId },
    query: 'id name email role { name }',
  });

  return user;
}`,
    });

    // File upload example
    if (
      spec.uiRequirements.interfaces.some(
        (ui) =>
          ui.toLowerCase().includes("upload") ||
          ui.toLowerCase().includes("image"),
      )
    ) {
      examples.push({
        title: "File Upload Field",
        description: "Handle file and image uploads",
        useCase: "For profile pictures, documents, or media content",
        code: `import { file, image } from '@keystone-6/core/fields';

fields: {
  avatar: image({ storage: 'my_images' }),
  document: file({ storage: 'my_files' }),
}

// In keystone.ts config:
storage: {
  my_images: {
    kind: 'local',
    type: 'image',
    storagePath: 'public/images',
    generateUrl: path => \`/images\${path}\`,
    serverRoute: {
      path: '/images',
    },
  },
}`,
      });
    }

    return examples;
  }

  private getImplementationPatterns(
    spec: ParsedSpecification,
  ): ImplementationPattern[] {
    const patterns: ImplementationPattern[] = [];

    // User-owned content pattern
    patterns.push({
      name: "User-Owned Content",
      description:
        "Content that belongs to specific users with appropriate access control",
      when: "When users create and manage their own content",
      steps: [
        "Add createdBy relationship field to User",
        "Set up resolveInput hook to auto-assign current user on create",
        "Configure access control to limit access to owners",
        "Add UI filtering to show only user's content",
      ],
      example: `// Full pattern implementation
export const UserContent = list({
  fields: {
    title: text({ validation: { isRequired: true } }),
    createdBy: relationship({
      ref: 'User',
      hooks: {
        resolveInput: ({ context, operation }) => {
          if (operation === 'create') {
            return { connect: { id: context.session?.itemId } };
          }
        }
      }
    }),
  },

  access: {
    operation: {
      create: ({ session }) => !!session,
      query: ({ session }) => session ? { createdBy: { id: { equals: session.itemId } } } : false,
      update: ({ session, item }) => session?.itemId === item.createdById,
      delete: ({ session, item }) => session?.itemId === item.createdById,
    },
  },
});`,
    });

    // Status workflow pattern
    if (
      spec.functionalRequirements.userWorkflows.some(
        (workflow) =>
          workflow.toLowerCase().includes("approve") ||
          workflow.toLowerCase().includes("publish") ||
          workflow.toLowerCase().includes("status"),
      )
    ) {
      patterns.push({
        name: "Status Workflow",
        description:
          "Content that goes through approval or publication workflows",
        when: "When content needs review, approval, or publication steps",
        steps: [
          "Add status field with appropriate options",
          "Set up hooks to validate status transitions",
          "Configure access control based on status",
          "Add timestamps for status changes",
        ],
      });
    }

    return patterns;
  }

  private inferFieldsFromSpec(spec: ParsedSpecification): FieldGuidance[] {
    const fields: FieldGuidance[] = [];

    // Always include basic fields
    fields.push({
      name: "title",
      type: "text",
      purpose: "Human-readable name/title for the item",
      validation: "isRequired: true",
      example: "text({ validation: { isRequired: true } })",
    });

    fields.push({
      name: "description",
      type: "text",
      purpose: "Detailed description of the item",
      example: 'text({ ui: { displayMode: "textarea" } })',
    });

    // Infer fields from UI requirements
    spec.uiRequirements.interfaces.forEach((ui) => {
      if (ui.toLowerCase().includes("email")) {
        fields.push({
          name: "email",
          type: "text",
          purpose: "Email address field",
          validation: "isEmail: true",
          example:
            'text({ validation: { isRequired: true }, isIndexed: "unique" })',
        });
      }

      if (
        ui.toLowerCase().includes("image") ||
        ui.toLowerCase().includes("photo")
      ) {
        fields.push({
          name: "image",
          type: "image",
          purpose: "Image upload field",
          example: 'image({ storage: "my_images" })',
        });
      }
    });

    return fields;
  }

  private inferRelationshipsFromSpec(
    spec: ParsedSpecification,
  ): RelationshipGuidance[] {
    const relationships: RelationshipGuidance[] = [];

    // Always include user relationship
    relationships.push({
      field: "createdBy",
      type: "one-to-many",
      target: "User",
      purpose: "Track which user created this item",
      example: 'relationship({ ref: "User" })',
    });

    return relationships;
  }

  private pascalCase(str: string): string {
    return str
      .replace(/(?:^|\s)(\w)/g, (_, char) => char.toUpperCase())
      .replace(/\s/g, "");
  }
}
